# --- Tab 4: Final Thresholds & Forecast Accuracy ---
with tab4:
    st.header("Final Thresholds & Forecast Accuracy")

    df_summary["FinalThreshold"] = df_summary[[
        "ManualThreshold", "95th_Pct", "GARCH_Forecast", "EVT_Threshold"
    ]].max(axis=1)

    @st.cache_data
    def load_best_mape_summary():
        try:
            log_df = pd.read_csv("logs/model_feedback_log.csv")
            latest = log_df.sort_values("RunDate", ascending=False).drop_duplicates("Currency")
            return latest[["Currency", "Model", "MAPE", "RMSE"]].rename(
                columns={"MAPE": "Best_MAPE", "RMSE": "Best_RMSE"}
            )
        except Exception as e:
            st.error(f"Error loading model summary: {e}")
            return pd.DataFrame(columns=["Currency", "Best_MAPE", "Model", "Best_RMSE"])

    best_mape_df = load_best_mape_summary()
    df_final = df_summary.merge(best_mape_df, on="Currency", how="left")

    selected_currency = st.selectbox("Select Currency", df_final["Currency"], key="tab4_currency")
    if selected_currency:
        row = df_final[df_final["Currency"] == selected_currency].iloc[0]

        st.subheader(f"{selected_currency}: Threshold Justification Summary")
        st.markdown(f"""
        - **Manual Threshold** = `{row['ManualThreshold']:.4f}` (OHLC based)  
        - **Dynamic Threshold** = `{row['FinalThreshold']:.4f}` (Max of GARCH, EVT, 95th percentile)  
        - **Best Forecasting Model** = `{row['Model']}` with MAPE = `{row['Best_MAPE']:.2f}%`  
        """)

        trend_df = df[df["Currency"] == selected_currency].copy().sort_values("Date")
        y_actual = trend_df["Volatility"].values
        dates = trend_df["Date"]

        mape_pct = row["Best_MAPE"] / 100 if pd.notnull(row["Best_MAPE"]) else 0.05
        upper_band = y_actual * (1 + mape_pct)
        lower_band = y_actual * (1 - mape_pct)
        flag_mask = (y_actual > upper_band) | (y_actual < lower_band)

        # Residual CI
        model_dict, _ = load_models(selected_currency)
        ci_upper, ci_lower, ci_dates = None, None, None
        if model_dict:
            try:
                vol_series = trend_df["Volatility"].values.reshape(-1, 1)
                vol_scaled = MinMaxScaler().fit_transform(vol_series)
                X_seq, y_seq = create_sequences(vol_scaled, 30)
                model_name = row["Model"]
                if model_name == "Random Forest":
                    preds = model_dict["Random Forest"].predict(X_seq)
                elif model_name == "LSTM":
                    preds = model_dict["LSTM"].predict(X_seq).ravel()
                else:
                    preds = model_dict[model_name].predict(X_seq)
                residuals = y_seq - preds
                resid_std = np.std(residuals)
                ci_upper = preds + 1.96 * resid_std
                ci_lower = preds - 1.96 * resid_std
                ci_dates = trend_df["Date"].iloc[-len(preds):]
            except Exception as e:
                st.warning(f"CI Error: {e}")

        fig = go.Figure()
        fig.add_trace(go.Scatter(x=dates, y=y_actual, name="Actual Volatility", line=dict(color="white")))
        fig.add_trace(go.Scatter(x=dates, y=upper_band, name="MAPE Upper", line=dict(dash="dot", color="green")))
        fig.add_trace(go.Scatter(x=dates, y=lower_band, name="MAPE Lower", line=dict(dash="dot", color="green")))
        fig.add_hline(y=row["ManualThreshold"], line_color="red", line_dash="dot", annotation_text="Manual")
        fig.add_hline(y=row["FinalThreshold"], line_color="orange", line_dash="dash", annotation_text="Dynamic")

        if ci_upper is not None:
            fig.add_trace(go.Scatter(x=ci_dates, y=ci_upper, name="CI Upper", line=dict(color="cyan", dash="dash")))
            fig.add_trace(go.Scatter(x=ci_dates, y=ci_lower, name="CI Lower", line=dict(color="cyan", dash="dash")))

        fig.add_trace(go.Scatter(x=dates[flag_mask], y=y_actual[flag_mask],
                                 mode="markers", name="Breach", marker=dict(color="red", size=8, symbol="x")))

        fig.update_layout(title=f"{selected_currency}: Volatility vs Thresholds",
                          xaxis_title="Date", yaxis_title="Volatility")
        st.plotly_chart(fig, use_container_width=True)

        st.markdown(f"""
        ### Summary

        - **Manual Threshold** is fixed and may miss spikes.
        - **Dynamic Threshold** adjusts based on current market regime.
        - **MAPE Bands** give a soft forecast range for early warnings.
        - **CI Bands** (from residuals) offer statistically valid confidence limits.
        """)
