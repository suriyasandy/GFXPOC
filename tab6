with tab6:
    st.header("Real-Time Recalibration Simulation")

    st.markdown("""
    This simulation shows how market volatility changes after **14 Oct 2024** (e.g. major economic events or FX swings)
    could render **manual thresholds** obsolete, while our **dynamic approach** adapts weekly.
    """)

    @st.cache_data
    def create_test_dataset():
        df_orig = pd.read_csv("reuters_fx_data.csv")
        df_orig["Date"] = pd.to_datetime(df_orig["Date"])
        df_orig.sort_values(["Currency", "Date"], inplace=True)
        
        # Filter pre-14-Oct for baseline and post-14-Oct for shock
        df_shock = df_orig[df_orig["Date"] > "2024-10-14"].copy()
        df_pre = df_orig[df_orig["Date"] <= "2024-10-14"].copy()

        # Recalculate rolling volatility on shocked period only
        df_shock["LogReturn"] = df_shock.groupby("Currency")["Close"].transform(lambda x: np.log(x).diff())
        df_shock["Volatility"] = df_shock.groupby("Currency")["LogReturn"].transform(lambda x: x.rolling(ROLL_WINDOW).std()) * ANNUALIZE

        impacted = ["INR", "JPY", "GBP"]
        df_shock["Shock"] = df_shock["Currency"].apply(lambda x: np.random.normal(1.5, 0.1) if x in impacted else 1.0)
        df_shock["Volatility_Shocked"] = df_shock["Volatility"] * df_shock["Shock"]

        df_final = pd.concat([df_pre, df_shock], axis=0).sort_values(["Currency", "Date"])
        df_final.to_csv("reuters_gfx_test_data.csv", index=False)
        return "reuters_gfx_test_data.csv"

    test_file = create_test_dataset()
    df_test = pd.read_csv(test_file)
    df_test["Date"] = pd.to_datetime(df_test["Date"])

    def safe_evt_threshold(x):
        tail = x[x > x.quantile(EVT_TAIL_PCT)]
        if len(tail.dropna()) < 5:
            return np.nan
        try:
            params = genpareto.fit(tail)
            return genpareto.ppf(0.999, *params)
        except:
            return np.nan

    recalibrated = df_test[df_test["Date"] > "2024-10-14"].groupby("Currency").agg(
        AvgVol_Shocked=("Volatility_Shocked", "mean"),
        New95thPct=("Volatility_Shocked", lambda x: x.quantile(PCT_THRESHOLD)),
        NewEVT=("Volatility_Shocked", safe_evt_threshold)
    ).reset_index()

    merged = df_summary[["Currency", "ManualThreshold"]].merge(recalibrated, on="Currency", how="inner")

    st.subheader("Comparison of Manual vs Recalibrated Thresholds")
    st.dataframe(merged, use_container_width=True)

    fig = px.bar(
        merged.melt(id_vars="Currency", value_vars=["ManualThreshold", "New95thPct", "NewEVT"]),
        x="Currency", y="value", color="variable", barmode="group",
        title="Manual vs Recalibrated Thresholds (Post-Volatility Shock)"
    )
    st.plotly_chart(fig, use_container_width=True)

    st.subheader("Insight")
    st.markdown("""
    - Manual thresholds stay fixed despite volatility shocks.
    - Dynamic recalibration captures changes in recent volatility.
    - EVT adjusts based on tail risks, unlike static manual bands.
    """)
